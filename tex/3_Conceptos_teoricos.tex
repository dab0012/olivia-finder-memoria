\capitulo{3}{Conceptos teóricos}
\section{Defectos en productos software}

Una especificación es una descripción de cómo se supone que un producto debe de estar construido para
que funcione. Si hablamos de software, puede ser más o menos detallada, desde especificaciones
matemáticas hasta manuales de usuario o descripciones funcionales. Un producto de software tiene
un defecto cuando su comportamiento no es compatible con lo que se esperaba de él.

Cuando se construye un proyecto de ingeniería de software, se parte de una \textit{Especificación
    de Requisitos de Software (SRS)}, que básicamente describe lo que se necesita del producto en general,
tanto cosas funcionales como otros detalles complementarios, como temas legales, estándares de calidad y restricciones. Y si el diseño involucra el uso de componentes externos, la especificación de esos componentes tiene que ser compatible con la SRS del proyecto. Porque, en el contexto de ese proyecto, si algo no encaja bien, se considera como un defecto en ese componente, y eso a su vez afectaría el proyecto en sí. O sea, es como una cadena de defectos.

Entonces, cuando hablamos de defectos en el software, hay que tener en cuenta todo lo que pueda disminuir
el valor del producto para sus usuarios. Ahí viene la parte más subjetiva, porque puede haber cosas que
algunos usuarios consideren como defectos, como una biblioteca de cálculo que arroja resultados
incorrectos, eso es un defecto objetivo, obviamente. Pero también pueden haber cambios en la licencia,
en la usabilidad, en el cumplimiento de ciertos estándares de calidad o seguridad, o en la estructura
de las interfaces externas, que para un usuario en particular también sean defectos.

Los defectos en el software pueden originarse por error o pueden ser el resultado de ataques
informáticos que buscan sabotear o aprovecharse del software para obtener algún beneficio.

\section{Repositorios de paquetes software}

En el desarrollo de software, los \textit{repositorios de paquetes} juegan un papel crucial al
proporcionar un entorno centralizado donde los desarrolladores pueden acceder, compartir y distribuir
bibliotecas de código predefinidas. Estos repositorios están diseñados específicamente para diferentes
plataformas y lenguajes de programación, brindando a los desarrolladores un acceso conveniente a una
amplia gama de recursos.

A lo largo del tiempo, han surgido numerosos repositorios de paquetes de software para diversas
plataformas y lenguajes. Por ejemplo, en el campo de la bioinformática, destaca \textit{Bioconductor}
como un importante repositorio que se enfoca en paquetes y herramientas para el análisis de datos
genómicos. En el ecosistema de Python, \textit{PyPI} (Python Package Index) es un repositorio central
que alberga una gran cantidad de paquetes para una amplia variedad de aplicaciones y bibliotecas.

En el panorama actual, los repositorios de paquetes de software siguen siendo vitales para la
comunidad de desarrollo. Brindan a los desarrolladores un acceso rápido y sencillo a una amplia
gama de funcionalidades y bibliotecas de código predefinidas, lo que les permite acelerar el desarrollo
de aplicaciones y proyectos. Además, estos repositorios fomentan la colaboración y el intercambio
de código entre los desarrolladores, promoviendo un entorno de desarrollo más dinámico y eficiente.

Un \textit{repositorio de paquetes} es básicamente un almacén de software que tiene como objetivo
distribuir librerías de componentes reutilizables. El término "paquete" se refiere al artefacto
adecuado para facilitar esta distribución, incluyendo la descarga, verificación e instalación de
los componentes por parte de los usuarios del repositorio. Normalmente, un paquete está compuesto
por código fuente y/o archivos binarios, junto con metadatos que incluyen directrices de compilación,
listas de requisitos, parámetros de configuración, referencias a la documentación y detalles de la
licencia, todo ello contenido en un único archivo comprimido.

Existen dos tipos principales de repositorios de paquetes: los \textit{repositorios de nivel de sistema},
integrados en los sistemas operativos, y los \textit{repositorios de nivel de aplicación}, integrados
en los entornos de desarrollo de diferentes lenguajes de programación. En ambos casos, suele haber un
sistema oficial o muy popular desde donde se realizan la mayoría de las descargas, lo que se conoce
como \textit{repositorios centralizados}.

En los últimos años, los repositorios de nivel de aplicación han experimentado un crecimiento exponencial
en términos de número de paquetes y cantidad de descargas. Por ejemplo, el repositorio oficial de
Node.js, llamado \textit{npm}, es actualmente el más grande en cuanto al número de componentes
publicados.

Para facilitar la interacción con los repositorios, existen herramientas llamadas \textit{gestores de
    paquetes}, que permiten a los desarrolladores automatizar la descarga e instalación recursiva de
componentes.

El software utilizado para desplegar y administrar los repositorios de paquetes se conoce como
\textit{gestor de repositorios}.

\section{Gestores de paquetes}

Los \textit{gestores de paquetes de software} desempeñan un papel fundamental al proporcionarnos
herramientas y funcionalidades para administrar la instalación, actualización y eliminación de
bibliotecas y dependencias en nuestros proyectos. Estos gestores están diseñados específicamente
para diferentes plataformas y lenguajes de programación, brindando a los desarrolladores una forma
eficiente de gestionar y distribuir el código.

Entre los gestores de paquetes más destacados, encontramos \textit{pip} en el ecosistema de Python,
el cual nos permite instalar y administrar de manera sencilla las bibliotecas necesarias para
nuestros proyectos en Python. Por otro lado, \textit{mvn} (Maven) es ampliamente utilizado en el
ámbito de Java para gestionar las dependencias y configuraciones de proyectos. Cada gestor de paquetes
tiene su propia sintaxis y funcionalidades específicas, pero todos comparten el objetivo común de
simplificar la gestión de bibliotecas y garantizar la resolución de dependencias.

En el panorama actual, los gestores de paquetes de software continúan desempeñando un papel
crucial en el desarrollo de software. Proporcionan a los desarrolladores una forma conveniente
y eficiente de administrar las bibliotecas y dependencias necesarias para sus proyectos, permitiéndoles
enfocarse en la implementación de funcionalidades sin preocuparse por la instalación manual y la
gestión de dependencias.

Además, estos gestores fomentan la reutilización de código y la colaboración dentro de la comunidad de desarrolladores, al facilitar el intercambio y la distribución de bibliotecas y proyectos. También simplifican la tarea de mantener actualizadas las dependencias, garantizando que los proyectos estén siempre al día y protegidos contra vulnerabilidades conocidas.


\section{Dependencias entre paquetes}

En el contexto de un proyecto de software, las \textit{dependencias externas} se refieren a las
conexiones con productos provenientes de actividades realizadas por agentes externos al equipo
del proyecto. Estos productos pueden ser requisitos, recursos o controles, como requisitos de clientes,
personal, hardware, software, procesos y estructuras de gestión.
Las dependencias externas están fuera del control directo del equipo del proyecto y, si no funcionan
según lo esperado, pueden comprometer el éxito del proyecto.

En el desarrollo de paquetes de software, al igual que en cualquier otro proyecto de software,
los desarrolladores reutilizan componentes distribuidos en otros paquetes, lo que genera dependencias
externas de software. Estas dependencias pueden ser \textit{directas}, cuando el paquete A invoca
directamente funciones de componentes del paquete B, o \textit{transitivas}, cuando el paquete A
invoca al paquete B, que a su vez utiliza el paquete C.
Las dependencias transitivas pueden dar lugar a largas cadenas de requisitos encadenados, que se
aplican a distintas fases del ciclo de desarrollo de software, como la implementación/construcción,
la prueba y el despliegue. Los gestores de paquetes generalmente se encargan de resolver automáticamente
todas estas dependencias según sea necesario, a través de las herramientas de los entornos de desarrollo,
integración continua y despliegue.

Por lo tanto, un defecto en un paquete alojado en un repositorio puede propagarse a otros paquetes
dependientes, tanto directa como transitivamente, y en última instancia, afectar a todos los proyectos
que utilicen dicho paquete. La propagación de este defecto está vinculada a la transferencia de la
versión dañada del paquete desde el repositorio. En otras palabras, el software que utiliza los
componentes almacenados en los entornos de ejecución locales no se verá afectado hasta que se
actualice la dependencia. Esto puede ocurrir en diferentes momentos, por lo que la propagación
a cada proyecto dependiente puede tener un retraso variable:

\begin{itemize}
    \item En el caso de software que incluye componentes compilados, el impacto se producirá cuando
          se realice una compilación después de descargar alguno de los paquetes comprometidos desde el
          repositorio.
    \item En el caso de software interpretado, con compilación JIT o con enlace dinámico de librerías,
          el impacto se producirá después de descargar alguno de los paquetes comprometidos desde el
          repositorio.
\end{itemize}

Estas descargas suelen ser realizadas por el gestor de paquetes y pueden deberse a diferentes motivos,
como la creación de un nuevo entorno de desarrollo, ejecución o pruebas (incluyendo entornos de
integración continua), o la decisión de incluir versiones actualizadas de las dependencias en los
requisitos del proyecto, ya sea por motivos funcionales o de seguridad.

\section{Teoría de grafos}

La teoría de grafos es un campo fundamental en las matemáticas discretas y la ciencia de la computación,
que estudia las propiedades y relaciones de los grafos. Un \textit{grafo} es una estructura compuesta
por un conjunto de \textit{nodos o vértices}, conectados entre sí por \textit{enlaces} llamados \textit{aristas}.
Estos grafos pueden representar una amplia variedad de situaciones y fenómenos, desde redes de
comunicación y relaciones sociales hasta sistemas de transporte y circuitos eléctricos.

La teoría de grafos se enfoca en el análisis y estudio de las propiedades estructurales y combinatorias
de los grafos, así como en el desarrollo de algoritmos eficientes para resolver problemas relacionados.
Se exploran conceptos fundamentales como la conectividad, los ciclos, los caminos más cortos, los flujos
y cortes mínimos, entre otros.

Los grafos encuentran aplicaciones en numerosos campos, incluyendo la optimización de rutas en
logística, la modelización de redes sociales, la planificación de proyectos, la programación lineal
y la criptografía, por mencionar solo algunos. La teoría de grafos proporciona herramientas conceptuales
y metodológicas para analizar y resolver problemas complejos en estos y otros dominios.

\section{Grafos dirigidos y no dirigidos}

En la teoría de grafos, existen dos tipos principales de grafos: los \textit{grafos dirigidos} y
los \textit{grafos no dirigidos}\footnote{Nota: En la teoría de grafos existen otros tipos de grafos,
    pero nos enfocaremos en estos dos tipos principales en este contexto}. Estas diferencias se
refieren a la forma en que se establecen las conexiones entre los vértices del grafo.

Un \textit{grafo no dirigido} es aquel en el que las aristas, que representan las conexiones
entre los vértices, no tienen una dirección asociada. En otras palabras, la relación entre dos
vértices es simétrica, lo que significa que si el vértice A está conectado con el vértice B,
entonces el vértice B también está conectado con el vértice A. En este tipo de grafo, la comunicación
o la relación entre los vértices se considera \textit{bidireccional}. Un ejemplo común de un grafo no
dirigido es una red social, donde los vértices representan personas y las aristas representan
amistades. La conexión entre dos personas en una red social no depende de la dirección.

Por otro lado, un \textit{grafo dirigido} es aquel en el que las aristas tienen una dirección
asociada. Esto significa que la relación entre dos vértices puede ser asimétrica, es decir, el
vértice A puede estar conectado con el vértice B, pero no necesariamente el vértice B está conectado
con el vértice A. En este tipo de grafo, la comunicación o la relación entre los vértices se considera
\textit{unidireccional}. Un ejemplo común de un grafo dirigido es una red de transporte, donde los
vértices representan ubicaciones y las aristas representan las rutas o los caminos que van en una
dirección específica.

\section{Métricas en la teoría de grafos}

En general, las \textit{métricas} son medidas o indicadores cuantitativos que se utilizan para evaluar
y cuantificar diferentes aspectos de un objeto, sistema o fenómeno\footnote{Las métricas también
    se conocen como medidas o indicadores de rendimiento}. Proporcionan una forma objetiva de medir y
comparar características específicas, permitiendo realizar análisis, tomar decisiones y realizar
mejoras basadas en datos concretos.

En el contexto de la teoría de grafos, las métricas se utilizan para analizar y caracterizar diferentes
propiedades y aspectos de los grafos. Estas métricas ofrecen medidas cuantitativas que describen la
estructura, la conectividad, la eficiencia y otros atributos relevantes de un grafo\footnote{
    Las métricas en la teoría de grafos son ampliamente utilizadas en campos como la informática, las
    redes sociales, la biología y la física, entre otros}.

\subsection{Grado}

El \textit{grado} de un vértice se refiere al número de aristas que están conectadas a ese vértice 
en particular\footnote{Nota: El grado de un vértice también se conoce como valencia}. El grado de 
un vértice es una métrica fundamental para comprender la conectividad y la importancia relativa de 
los vértices dentro de un grafo. En un grafo no dirigido, el grado de un vértice se calcula contando 
el número total de aristas incidentes a ese vértice. En un grafo dirigido, se distingue entre el grado 
de entrada (número de aristas entrantes) y el grado de salida (número de aristas salientes) de un 
vértice.

El grado de un vértice puede proporcionar información valiosa sobre la estructura y las propiedades 
del grafo en general. Por ejemplo, los vértices con un grado alto suelen desempeñar un papel central 
en la comunicación y la transferencia de información dentro de un grafo. También puede revelar la 
existencia de vértices aislados (grado cero) o vértices de grado bajo, que pueden tener implicaciones 
en la conectividad y la eficiencia de un grafo.

Además, el análisis de la distribución de los grados en un grafo puede revelar patrones interesantes, 
como la presencia de hubs o nodos altamente conectados que desempeñan un papel clave en la red. 
Estudiar el grado de los vértices y su distribución puede ser útil para comprender la robustez, 
la centralidad y otras propiedades estructurales de un grafo.

\subsection{Centralidad}

La \textit{centralidad} es una medida utilizada en la teoría de grafos para identificar los vértices 
más importantes o influyentes dentro de un grafo. Se basa en la idea de que algunos nodos tienen un 
papel más destacado en la transmisión de información o la propagación de influencias en una red.

Existen diferentes métricas de centralidad que se utilizan para evaluar la importancia de los 
nodos en función de diferentes criterios. Dos de las métricas de centralidad más comunes son la 
centralidad de intermediación y la centralidad de cercanía.

La \textit{centralidad de intermediación} (\textit{betweenness centrality}) mide la importancia de 
un nodo en función de la cantidad de veces que ese nodo se encuentra en el camino más corto entre 
otros pares de nodos en el grafo. Un nodo con una alta centralidad de intermediación actúa como un 
puente o intermediario entre otros nodos, desempeñando un papel crucial en la comunicación y el 
flujo de información dentro de la red.

Por otro lado, la \textit{centralidad de cercanía} (\textit{closeness centrality}) se refiere a la 
proximidad de un nodo con respecto a todos los demás nodos en el grafo. Un nodo con una alta 
centralidad de cercanía está más cerca en términos de distancia geodésica de todos los demás nodos, 
lo que implica que puede acceder rápidamente a la información y transmitirla eficientemente a otros 
nodos en la red.

Hacemos una mención especial a \textit{PageRank}\footnote{Nota: Desarrollado por Larry Page y Sergey 
Brin} por su importancia en estos últimos años. PageRank es un algoritmo utilizado como medida de 
centralidad en la teoría de grafos. Fue desarrollado por Google, como parte de su motor de búsqueda 
original.

PageRank se basa en el concepto de que una página web es importante si es enlazada por otras 
páginas importantes. Considera los enlaces como votos de confianza, donde los enlaces provenientes 
de páginas con mayor autoridad tienen un peso mayor. Además, el algoritmo tiene en cuenta la 
cantidad total de enlaces que apuntan a una página y la importancia de esas páginas de origen.

El nombre \textit{"PageRank"} se deriva del apellido de su inventor, pero también hace referencia 
a la noción de \textit{ranking} o clasificación de páginas web. Page y Brin implementaron el 
algoritmo PageRank en el motor de búsqueda de Google, que se lanzó en 1998. Fue una de 
las innovaciones clave que distinguió a Google de otros motores de búsqueda de la época, ya que 
permitía generar resultados más relevantes y de mayor calidad.

Con el tiempo, PageRank se convirtió en una medida ampliamente utilizada para evaluar la importancia 
de los nodos en diversos tipos de redes, no solo en la web. Ha encontrado aplicaciones en áreas como 
las redes sociales, la biología de sistemas, la epidemiología y la física de redes, entre otras.

